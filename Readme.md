# Работа "Исследование и оптимизация поиска в хеш-таблице"

## Цель работы

- Изучить работу хэш-таблиц
- Сравнить работу различных хэш-функций
- Оптимизировать поиск слов в хеш-таблице

## Теоретическая справка

**Хэш-функция** - функция, преобразующая входной массив данных в некоторую битовую строку по заданному алгоритму. Такое преобразование называется **хешированием**.

**Хэш-таблица** - структура данных, хранящая пары (ключ, значение), позволяющая выполнять 3 операции: добавление новой пары, удаление пары и поиск по ключу. Существуют 2 основных варианта хеш-таблиц: с открытой адресацией и со списками. В первом случае, таблица является массивом значений ``H``, во втором - массивом списков значений ``H``. К таблице привязана хеш-функция. Перед выполнением любой операции значение хешируется и результат: ``i = hash(key) % sizeof(H)`` является индексом в массиве ``H``. Операция добавления/поиска/удаления значения производится в соответствующей ячейке массива ``H[i]`` или в списке по индексу ``i``, в зависимости от варианта таблицы.

**Коэффицент заполнения хеш-таблицы** - число хранимых в таблице элементов, делённое на размер массива ``H`` - является важной характеристикой, от которой зависит время выполнения операций. В случае идеальной хеш-функции, равновероятно распределяющей значения по ключам, среднее время работы операции поиска элемента составляет ``Θ(1 + α)``, где ``α`` — коэффициент заполнения таблицы.

**Заселённость** - это число элементов, хранящееся в соотвествующем списке хеш-таблицы, (в реализации таблицы с массивом значений ``H``, заселённость каждой ячейки равна 1 и не имеет смысла).

## Экспериментальная установка

Измерения проводятся с хеш-таблицей, содержащей массив структур двухсвязных списков:

```
struct HashTable
{
    size_t size;
    List*  lists;
    int (*hash_function)(const char*);
};
```

К ней также привязана функция хеширования, чтобы не возникало ошибок поиска и удаления элементов. Структура ещё содержит размер массива списков и суммарное число добавленных слов.

## Часть 1. Исследование хэш-фунцкий.

Первая часть работы посвящена исследованию эффективности различных функций хэширования.

### Хэш-функции

Для исследования были выбраны нижеперечисленные функции. Они принимают строку символов и возвращают её хеш в виде целочисленного значения.

#### ConstHash - постоянное значение
```
int HashConst(const char* string)
{
    return CONSTANT_HASH;
}
```
Недостатки этой функции очевидны, она вообще не распределяет входные данные по спискам.

#### LenHash - длина строки
```
int HashLen(const char* string)
{
    return (int)strlen(string);
}
```
Немного лучше, однако на данном массиве данных функция неэффективна из-за ограниченности длины слов в языке, к тому же влияет распределение слов в английском языке. Так, например, слов длины 3-4 в английском словаре больше остальных. что влияет на неранвомерность рапсределения.

#### FirstSymbHash - первый символ
```
int HashFirstSymb(const char* string)
{
    return (int)string[0];
}
```
Показатели дисперсии и стандартного отклонения ещё уменьшились, но функция также является ограниченной, её результат всегда лежит в диапазоне от 0 до 255, к тому же на входном массиве английских слов она может принимать значения от 65 до 122 (английские буквы от A до z).

#### SumHash - контрольная сумма
```
int HashSum(const char* string)
{
    int hash = 0;
    size_t len = strlen(string);
    for (int symbol_i = 0; symbol_i < len; symbol_i++)
        hash+=string[symbol_i];
    return hash;
}
```
Функция работает уже сильно лучше, и действительно, контрольная сумма применяется уже гораздо чаще предыдущих хеш-функций, например, для проверки входного файла.

#### RolHash - циклический сдвиг влево
```
int HashRol(const char* string)
{
    int hash = 0;
    size_t len = strlen(string);
    for (int symbol_i = 0; symbol_i < len; symbol_i++)
        hash = ROL(hash, 1) ^ string[symbol_i];
    return hash;
}
```
Чел харошшшш!

#### RorHash - циклический сдвиг вправо
```
int HashRor(const char* string)
{
    int hash = 0;
    size_t len = strlen(string);
    for (int symbol_i = 0; symbol_i < len; symbol_i++)
        hash = ROR(hash, 1) ^ string[symbol_i];
    return hash;
}
```
Казалось бы, функция похожа на предыдущую и должна давать тоже неплохой результат, однако её эффективность сложно противопоставить RolHash. Интересно...

#### ... (собственная функция хэширования)
```
int MyHash(const char* string)
{
    int hash = 0, i;
    int rotate = 2;
    int seed = 0x1A4E41U;
    int len = strlen(string);
    for (int i = 0; i < len; i++)
    {
        hash += sTable[(string[i] + i) & 255];
        hash = (hash << (32 - rotate) ) | (hash >> rotate);
        hash = (hash + i) * seed;
    }
  return (hash + len) * seed;
}
```
Нормас, результат крутой.

#### GnuHash
```
    int GnuHash(const char* value)
    {
        int hash = 5381;

        for (unsigned char c = *value; c != '\0'; c = *++value)
            hash = hash * 33 + c;

        return hash;
    }
```
Функция показала наилучшие результаты на данном массиве слов.

### Методы исследования

Исследование проводилось на массиве неповторяющихся слов. Для этого был выбран английский словарь, суммарно содержащий около 50000 слов, затем, при помощи python из него было случайным образом выбрано 10000 неповторяющихся слов. Проводилось заполнение хэш-таблицы значениями при помощи каждой из представленных функций. Затем проанализированы гистограммы заселённости, т.е. количества эдементов в каждом из списков хэш-таблицы, в зависимости от хэш-функции, посчитаны среднеквадратичные отклонения и т.д.

### Результаты измерений

Таким образом, различия в хеш-функциях видны невооружённым взглядом, однако приведу некоторые количественные характеристики:

*таблица средних значений, дисперсий, стандартных отклонений*

### Выводы

Таким образом, на выбранном массиве данных наиболее эффективными оказались функции MyHash и GnuHash, они показали похожие значения дисперсии. Были выявлены недостатки использования функций контрольной суммы или первого символа элемента.

## Часть 2. Оптимизация поиска в хэш-таблице

Для дальнейшей работы была выбрана наиболее эффективная, по результатам первой части работы, хэш-функция - ``MyHash``. Задача состоит в оптимизации поиска слова в хеш-таблице, а именно, функция поиска принимает на вход слово, считает его хеш и проверяет наличие его в соответствующем списке таблицы. Сначала юыла предпринята идея брать 10000 случайных слов из того же полного словаря и искать их в построенной ранее хеш-таблице. Измерения показывают, что выбранные при помощи python "случайные слова" из того же полного словаря имеют пересечение в около 20% (~1900-2100 слов из 10000 в пересечении) с массивом из первой части работы. Чтобы уравновесить число пересекающихся и непересекающихся слов, я изначально выберу из всего словаря 20000 слов, из которых уже затем буду выбирать случайные 10000 слов для заполнения таблицы и 10000 слов для поиска в ней. Измерения показывают, что при этом процент пересечения этих множеств составляет около 50% (~4900-5100 из 10000 слов в пересечении), что больше подходит для эксперимента. Чтобы увеличить вклад поиска в таблице при профилировании программы и явно выявить лимитирующие в нём факторы, я запускаю цикл поиска слов в хеш-таблицы 200 раз. Кстати за размер хеш-таблицы было выбрано простое число - 6673, потому что существует теорема...

### Лимитирующие факторы

Проведя описанные действия и воспользовавшись утилитой ``valgrind --callgrind`` и просмотрщиком ``kcachegrind`` для выявления узких мест программы были получены следующие результаты.

### Оптимизация 1: <Флаги компилятора>
Воспользуемся возможностями, которые предоставляет нам компилятор, а именно - используем флага оптимизации -O3, который уже ранее показал свою эффективность в предыдущих задачах.

|Время работы           |   |
|:----------------------|:-:|
|Абсолютное ускорение   |   |
|Относительное ускорение|   |

### Оптимизация 2: <Математические принципы хеш-таблицы>

У хеш-таблицы есть несколько доказанных математических принципов, строго доказанных. Максимальная производительность может быть достигнута при размере, являющимся простым числом, при этом таком, чтобы средняя длина списка составляла 1.5 элемента. То есть количество списков в таблице я изначально выберу в зависимости от колчиества слов, равное 6673 - простое число. Производительность программы поиска при этом возрастёт в разы:

|Время работы           |   |
|:----------------------|:-:|
|Абсолютное ускорение   |   |
|Относительное ускорение|   |

### Оптимизация 3: <AVX2-инструкции сравнения>

Профилирование программы даёт понять, что наиболее узким местом работы является инструкция strcmp_avx2, оптимизируем её, используя intrinsic-инструкции.

|Время работы           |   |
|:----------------------|:-:|
|Абсолютное ускорение   |   |
|Относительное ускорение|   |

### Оптимизация 4: <Ассемблерная функция хеширования>

Попробуем заменить С функцию хеширования GnuHash на написанную на ассемблере функцию.

|Время работы           |   |
|:----------------------|:-:|
|Абсолютное ускорение   |   |
|Относительное ускорение|   |

### Оптимизация 5: <Аппаратная функция хеширования>

В возможности моего процессора входит инструкция, выполняющаяся над вектором данных - криптографическая хеш функция ... crc32 ... Преимущество в том,что инструкция реализована аппаратурно, а значит, занимает малое количество тактов, однако из недостатков - она может оказаться неприменимой для других версий процессоров. Используем её вместо GnuHash. Функция имеет такое распределение:

А результат измерений времени после замены представлен в таблице:

|Время работы           |   |
|:----------------------|:-:|
|Абсолютное ускорение   |   |
|Относительное ускорение|   |

### Выводы

Таким образом!
