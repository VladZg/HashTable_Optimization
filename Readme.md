# Работа "Исследование и оптимизация поиска в хеш-таблице"

## Цель работы

- Изучить работу хэш-таблиц
- Сравнить работу различных хэш-функций
- Оптимизировать поиск слов в хеш-таблице

## Теоретическая справка

**Хэш-функция** - функция, преобразующая входной массив данных в некоторую битовую строку по заданному алгоритму. Такое преобразование называется **хешированием**.

**Хэш-таблица** - структура данных, хранящая пары (ключ, значение), позволяющая выполнять 3 операции: добавление новой пары, удаление пары и поиск по ключу. Существуют 2 основных варианта хеш-таблиц: с открытой адресацией и со списками. В первом случае, таблица является массивом значений ``H``, во втором - массивом списков значений ``H``. К таблице привязана хеш-функция. Перед выполнением любой операции значение хешируется и результат: ``i = hash(key) % sizeof(H)`` является индексом в массиве ``H``, в котором и производится операция.

**Коэффицент заполнения хеш-таблицы** - число хранимых в таблице элементов, делённое на размер массива ``H`` - является важной характеристикой, от которой зависит время выполнения операций. В случае идеальной хеш-функции, равновероятно распределяющей значения по ключам, среднее время работы операции поиска элемента составляет ``Θ(1 + α)``, где ``α`` — коэффициент заполнения таблицы.

## Часть 1. Исследование хэш-фунцкий.

В первой части работы проводилось исследование эффективности различных функций хэширования.

### Хэш-функции

Для исследования были выбраны нижеперечисленные функции. Они принимают строку символов и возвращают её хеш в виде целочисленного значения.

#### ConstHash - постоянное значение
```
int HashConst(const char* string)
{
    return CONSTANT_HASH;
}
```
#### LenHash - длина строки
```
int HashLen(const char* string)
{
    return (int)strlen(string);
}
```
#### FirstSymbHash - первый символ
```
int HashFirstSymb(const char* string)
{
    return (int)string[0];
}
```
#### SumHash - контрольная сумма
```
int HashSum(const char* string)
{
    int hash = 0;
    size_t len = strlen(string);
    for (int symbol_i = 0; symbol_i < len; symbol_i++)
        hash+=string[symbol_i];
    return hash;
}
```
#### RolHash - циклический сдвиг влево
```
int HashRol(const char* string)
{
    int hash = 0;
    size_t len = strlen(string);
    for (int symbol_i = 0; symbol_i < len; symbol_i++)
        hash = ROL(hash, 1) ^ string[symbol_i];
    return hash;
}
```
#### RorHash - циклический сдвиг вправо
```
int HashRor(const char* string)
{
    int hash = 0;
    size_t len = strlen(string);
    for (int symbol_i = 0; symbol_i < len; symbol_i++)
        hash = ROR(hash, 1) ^ string[symbol_i];
    return hash;
}
```
#### ... (собственная функция хэширования)
```
int MyHash(const char* string)
{
    int hash = 0, i;
    int rotate = 2;
    int seed = 0x1A4E41U;
    int len = strlen(string);
    for (int i = 0; i < len; i++)
    {
        hash += sTable[(string[i] + i) & 255];
        hash = (hash << (32 - rotate) ) | (hash >> rotate);
        hash = (hash + i) * seed;
    }
  return (hash + len) * seed;
}
```

#### GnuHash
```
    int GnuHash(const char* value)
    {
        int hash = 5381;

        for (unsigned char c = *value; c != '\0'; c = *++value)
            hash = hash * 33 + c;

        return hash;
    }
```
### Методы исследования

Исследование проводилось на массиве неповторяющихся слов. Для этого был выбран английский словарь, суммарно содержащий около 50000 слов, затем, при помощи python из него было случайным образом выбрано 10000 неповторяющихся слов. Проводилось заполнение хэш-таблицы значениями при помощи каждой из представленных функций. Затем проанализированы гистограммы заселённости, т.е. количества эдементов в каждом из списков хэш-таблицы, в зависимости от хэш-функции, посчитаны среднеквадратичные отклонения и т.д.

### Результаты измерений

Таким образом, различия в хеш-функциях видны невооружённым взглядом, однако приведу некоторые количественные характеристики:

*таблица средних значений, дисперсий, стандартных отклонений*

### Выводы

Таким образом, на выбранном массиве данных наиболее эффективными оказались функции MyHash и GnuHash, они показали похожие значения дисперсии. Были выявлены недостатки использования функций контрольной суммы или первого символа элемента.

## Часть 2. Оптимизация поиска в хэш-таблице

Для дальнейшей работы была выбрана наиболее эффективная, по результатам первой части работы, хэш-функция - ``MyHash``. Задача состоит в оптимизации поиска слова в хеш-таблице, а именно, функция поиска принимает на вход слово, считает его хеш и проверяет наличие его в соответствующем списке таблицы. Сначала юыла предпринята идея брать 10000 случайных слов из того же полного словаря и искать их в построенной ранее хеш-таблице. Измерения показывают, что выбранные при помощи python "случайные слова" из того же полного словаря имеют пересечение в около 20% (~1900-2100 слов из 10000 в пересечении) с массивом из первой части работы. Чтобы уравновесить число пересекающихся и непересекающихся слов, я изначально выберу из всего словаря 20000 слов, из которых уже затем буду выбирать случайные 10000 слов для заполнения таблицы и 10000 слов для поиска в ней. Измерения показывают, что при этом процент пересечения этих множеств составляет около 50% (~4900-5100 из 10000 слов в пересечении), что больше подходит для эксперимента. Чтобы увеличить вклад поиска в таблице при профилировании программы и явно выявить лимитирующие в нём факторы, я запускаю цикл поиска слов в хеш-таблицы 200 раз. Кстати за размер хеш-таблицы было выбрано простое число - 6673, потому что существует теорема...

### Лимитирующие факторы

Проведя описанные действия и воспользовавшись утилитой ``valgrind --callgrind`` и просмотрщиком ``kcachegrind`` для выявления узких мест программы были получены следующие результаты.

### Оптимизация 1: <Флаги компилятора>
Воспользуемся возможностями, которые предоставляет нам компилятор, а именно - используем флага оптимизации -O3, который уже ранее показал свою эффективность в предыдущих задачах.

|Время работы           |   |
|:----------------------|:-:|
|Абсолютное ускорение   |   |
|Относительное ускорение|   |

### Оптимизация 2: <Математические принципы хеш-таблицы>

У хеш-таблицы есть несколько доказанных математических принципов, строго доказанных. Максимальная производительность может быть достигнута при размере, являющимся простым числом, при этом таком, чтобы средняя длина списка составляла 1.5 элемента. То есть количество списков в таблице я изначально выберу в зависимости от колчиества слов, равное 6673 - простое число. Производительность программы поиска при этом возрастёт в разы:

|Время работы           |   |
|:----------------------|:-:|
|Абсолютное ускорение   |   |
|Относительное ускорение|   |

### Оптимизация 3: <AVX2-инструкции сравнения>

Профилирование программы даёт понять, что наиболее узким местом работы является инструкция strcmp_avx2, оптимизируем её, используя intrinsic-инструкции.

|Время работы           |   |
|:----------------------|:-:|
|Абсолютное ускорение   |   |
|Относительное ускорение|   |

### Оптимизация 4: <Ассемблерная функция хеширования>

Попробуем заменить С функцию хеширования GnuHash на написанную на ассемблере функцию.

|Время работы           |   |
|:----------------------|:-:|
|Абсолютное ускорение   |   |
|Относительное ускорение|   |

### Оптимизация 5: <Аппаратная функция хеширования>

В возможности моего процессора входит инструкция, выполняющаяся над вектором данных - криптографическая хеш функция ... crc32 ... Преимущество в том,что инструкция реализована аппаратурно, а значит, занимает малое количество тактов, однако из недостатков - она может оказаться неприменимой для других версий процессоров. Используем её вместо GnuHash. Функция имеет такое распределение:

А результат измерений времени после замены представлен в таблице:

|Время работы           |   |
|:----------------------|:-:|
|Абсолютное ускорение   |   |
|Относительное ускорение|   |

### Выводы

Таким образом!
